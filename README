# GitHub Codespaces ♥️ Express
# Automated Container deployment and Administration in the cloud - CA 1 

This project is about automating vm infastructure and configurations along with CI/CD integration.

### Tools used : Terraform + Docker + Azure VM + Azure ACR + Github actions

## Part 1: Infrastructure Setup 

### Terraform Script Explanation for VM and other resources creation
All the variables are stored in variables.tf

````
resource "random_pet" "rg_name" {
     prefix = var.resource_group_name_prefix
}

````
This resource generates a random name for the resource group using the random_pet provider, with a prefix defined by the resource_group_name_prefix variable

````
resource "azurerm_resource_group" "rg" {
  location = var.resource_group_location
  name     = random_pet.rg_name.id
}

````
This resource creates an Azure Resource Group with the name generated by the random_pet resource and location specified by the resource_group_location variable

````
resource "azurerm_virtual_network" "caone_terraform_network" {
  name                = "caoneVnet"
  address_space       = ["10.0.0.0/16"]
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name
}

````
This resource creates an Azure Virtual Network within the resource group. It specifies the address space and links it to the location and name of the resource group

````
resource "azurerm_public_ip" "caone_terraform_public_ip" {
  name                = "caonePublicIP"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name
  allocation_method   = "Static"
}

````
This resource creates a static public IP address within the resource group

````
resource "azurerm_network_security_group" "caone_terraform_nsg" {
  name                = "caoneNetworkSecurityGroup"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name

  security_rule {
    name                       = "SSH"
    priority                   = 1001
    direction                  = "Inbound"
    access                     = "Allow"
    protocol                   = "Tcp"
    source_port_range          = "*"
    destination_port_range     = "22"
    source_address_prefix      = "*"
    destination_address_prefix = "*"
  }

  security_rule {
    name                       = "HTTP"
    priority                   = 1002
    direction                  = "Inbound"
    access                     = "Allow"
    protocol                   = "Tcp"
    source_port_range          = "*"
    destination_port_range     = "80"
    source_address_prefix      = "*"
    destination_address_prefix = "*"
  }

  security_rule {
    name                       = "HTTPS"
    priority                   = 1003
    direction                  = "Inbound"
    access                     = "Allow"
    protocol                   = "Tcp"
    source_port_range          = "*"
    destination_port_range     = "443"
    source_address_prefix      = "*"
    destination_address_prefix = "*"
  }
}

````
This resource creates a Network Security Group (NSG) with rules for SSH, HTTP, and HTTPS traffic

````
resource "azurerm_network_interface" "caone_terraform_nic" {
  name                = "caoneNIC"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name

  ip_configuration {
    name                          = "caone_nic_configuration"
    subnet_id                     = azurerm_subnet.caone_terraform_subnet.id
    private_ip_address_allocation = "Dynamic"
    public_ip_address_id          = azurerm_public_ip.caone_terraform_public_ip.id
  }
}

````
This resource creates a network interface card (NIC) with a dynamic private IP and an attached public IP

````
resource "azurerm_network_interface_security_group_association" "example" {
  network_interface_id      = azurerm_network_interface.caone_terraform_nic.id
  network_security_group_id = azurerm_network_security_group.caone_terraform_nsg.id
}

````
This resource associates the previously created NSG with the network interface

````
resource "random_id" "random_id" {
  keepers = {
    resource_group = azurerm_resource_group.rg.name
  }
  byte_length = 8
}

````
This resource generates a random ID for the storage account, ensuring it’s unique

````
resource "azurerm_storage_account" "caone_storage_account" {
  name                     = "diag${random_id.random_id.hex}"
  location                 = azurerm_resource_group.rg.location
  resource_group_name      = azurerm_resource_group.rg.name
  account_tier             = "Standard"
  account_replication_type = "LRS"
}

````
This resource creates a storage account used for boot diagnostics

````
resource "azurerm_linux_virtual_machine" "caone_terraform_vm" {
  name                  = "caonevm"
  location              = azurerm_resource_group.rg.location
  resource_group_name   = azurerm_resource_group.rg.name
  network_interface_ids = [azurerm_network_interface.caone_terraform_nic.id]
  size                  = "Standard_B1s"

  os_disk {
    name                 = "caoneOsDisk"
    caching              = "ReadWrite"
    storage_account_type = "Premium_LRS"
  }

  source_image_reference {
    publisher = "Canonical"
    offer     = "0001-com-ubuntu-server-jammy"
    sku       = "22_04-lts-gen2"
    version   = "latest"
  }

  computer_name               = "hostname"
  admin_username              = var.username
  admin_password              = var.admin_password
  disable_password_authentication = false
  boot_diagnostics {
    storage_account_uri = azurerm_storage_account.caone_storage_account.primary_blob_endpoint
  }
}

````
This resource creates an Ubuntu virtual machine with network interface, OS disk, and boot diagnostics configurations

````
resource "azurerm_virtual_machine_extension" "custom_script" {
  name                 = "InstallCustomSoftware"
  virtual_machine_id   = azurerm_linux_virtual_machine.caone_terraform_vm.id
  publisher            = "Microsoft.Azure.Extensions"
  type                 = "CustomScript"
  type_handler_version = "2.0"
  settings = <<SETTINGS
    {
      "fileUris": ["https://somewebsite/scripts/install.sh"],
      "commandToExecute": "./install.sh"
    }
SETTINGS
}

````
This resource adds a custom script extension to the virtual machine to install NGINX and Docker. The script is downloaded from a specified URL and executed on the VM

## Part 2: Configuration Management 

### Terraform Post Deployment Script Explanation for Docker setup

````
sudo apt-get update

````
Updates the package list on the system, ensuring latest information about available packages and their dependencies are available

````
sudo apt-get install ca-certificates curl
sudo install -m 0755 -d /etc/apt/keyrings
sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
sudo chmod a+r /etc/apt/keyrings/docker.asc

````
Add Docker's official GPG key

````
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
  $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update

````
Add the repository to Apt sources

````
sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

````
Install the Latest Version of Docker

## Part 3: Docker Container Deployment 

### Terraform Post Deployment Script Explanation for NGINX and Docker container deployment

````
sudo apt-get install -y nginx
````

Install nginx

````
sudo curl -o /home/content-nginx.txt https://pastorag.blob.core.windows.net/scripts/content-nginx.txt

sudo cp /home/content-nginx.txt $DESTINATION
````
Download reverse proxy nginx config file from URL and copy the content to "/etc/nginx/sites-enabled/default"

````
sudo systemctl restart nginx

````
Restart nginx as above config file changed

````
curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash

````
Install Azure cli

````
sudo az acr login --name <samplename>  --username <sampleusername> --password <samplepassword>

````
Login to Azure ACR

````
sudo docker pull netca.azurecr.io/samples/ca-one-app:latest

````
Pull docker image from Azure ACR

````
sudo docker run --restart always -d -p 3000:3000 --name ca-one-container netca.azurecr.io/samples/ca-one-app:latest

````
Run the pulled docker image from ACR on port 3000 and set it to restart when system reboots

## Part 4: CI/CD Pipeline Integration 

### Github actions workflow script explanation

````
- name: Checkout code
  uses: actions/checkout@v4

````
Checks out the repository's code so the workflow can access it

````
- name: Set up Docker Buildx
  uses: docker/setup-buildx-action@v3

````
Sets up Docker Buildx, a tool for building multi-platform Docker images

````
- name: Log in to Azure Container Registry
  uses: docker/login-action@v3
  with:
    registry: ${{ secrets.ACR_NAME }}.azurecr.io
    username: ${{ secrets.ACR_USERNAME }}
    password: ${{ secrets.ACR_PASSWORD }}

````
Logs into the Azure Container Registry using credentials stored in GitHub Secrets

````
- name: Build Docker image and push
  uses: docker/build-push-action@v5
  with:
    context: .
    push: true
    tags: netca.azurecr.io/samples/ca-one-app:latest

````
Builds the Docker image from the current directory (context: .) and pushes it to the Azure Container Registry under the specified tag

````
- name: Connect to Server and Pull
  uses: appleboy/ssh-action@v1.0.3
  with:
    host: ${{ secrets.SERVER_HOST }}
    username: ${{ secrets.SERVER_USERNAME }}
    password: ${{ secrets.PASSWORD }}
    command_timeout: 30m
    script: |
        sudo docker pull netca.azurecr.io/samples/ca-one-app:latest
        sudo docker stop ca-one-container
        sudo docker rm ca-one-container
        sudo docker run -d -p 3000:3000 --name ca-one-container --restart always netca.azurecr.io/samples/ca-one-app:latest
        echo "ca-one-app container started"

````
Connects to the server via SSH, pulls the Docker image, stops any existing container with the same name, removes it, and runs a new container with the latest image. It binds the container's port 3000 to the host's port 3000 and ensures the container restarts always